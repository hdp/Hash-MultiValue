NAME
    Hash::MultiValue - Store multiple values per key

SYNOPSIS
      use Hash::MultiValue;

      my $hash = Hash::MultiValue->new(
          foo => 'a',
          foo => 'b',
          bar => 'baz',
      );

      # $hash is an object, but can be used as a hashref and DWIMs!

      print $hash->{foo};        # 'b' (the last entry)
      my @foo = @{$hash->{foo}}; # ('a', 'b')

      # Object Oriented get
      my $foo = $hash->get('foo'); # always 'b', independent of context
      my @foo = $hash->getall('foo'); # ('a', 'b')

      keys %$hash; # ('foo', 'bar') not guaranteed to be ordered
      $hash->keys; # ('foo', 'bar') guaranteed to be ordered

      # get a plain hash. values are all array references
      %hash = $hash->as_hash;

      # get a pair so you can pass it to new()
      @pairs = $hash->flatten; # ('foo' => 'a', 'foo' => 'b', 'bar' => 'baz')

DESCRIPTION
    Hash::MultiValue is an object that behaves like a hash reference that
    may contain multiple values per key, inspired by MultiDict of WebOb.

    It uses "tie" to reflect writes to a hash, and also a blessed objects
    with "overload" to return values so it does the right thing in
    stringification and array derefernces context.

WHY THIS MODULE
    In a typical web application, the request parameters (a.k.a CGI
    parameters) can be single value or multi values. Using CGI.pm style
    "param" is one way to deal with this problem (and it is good), but
    there's another approach to convert parameters into a hash reference,
    like Catalyst's "$c->req->parameters" does, and it sucks.

    Why? Because the value could be just a scalar if there is one value and
    an array ref if there are multiple, depending on *user input* rather
    than *how you code it*. So your code should always be like this to be
    defensive:

      my $p = $c->req->parameters;
      my @maybe_multi = ref $p->{m} eq 'ARRAY' ? @{$p->{m}} : ($p->{m});
      my $must_single = ref $p->{m} eq 'ARRAY' ? $p->{m}->[0] : $p->{m};

    Otherwise you'll get a random runtime exception of *Can't use string as
    an ARRAY ref* or get stringified array *ARRAY(0xXXXXXXXXX)* as a string,
    *depending on user input* and which is miserable and insecure.

    This module provides a (black magic-ish, I admit) solution to this by
    returning a tied hash, which value returns a blessed object that behaves
    correctly when it's evaluated as a string/number (i.e. a single value)
    or as an array reference (i.e. multiple values).

    Yes, there is Tie::Hash::MultiValue and this module tries to solve
    exactly the same problem, but in more DWIM fashion.

NOTES ABOUT ref
    If your existing application uses "ref" to check if the hash value is
    multiple, i.e.:

      my $form = $req->parameters;
      my @v = ref $form->{v} eq 'ARRAY' ? @{$form->{v}} : ($form->{v});

    The "ref" call would return the string *Hash::MultiValue::Value* by
    default, so your code always assumes that it is a single value element.
    To avoid this, you can use UNIVERSAL::ref module, and then if
    "$form->{v}" has multiple values "ref" would return "ARRAY" instead, and
    your code would continue working.

AUTHOR
    Tatsuhiko Miyagawa <miyagawa@bulknews.net>

LICENSE
    This library is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself.

SEE ALSO
    <http://pythonpaste.org/webob/#multidict> Tie::Hash::MultiValue

